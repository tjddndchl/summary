# 디자인 패턴 (Design Patterns)

디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제들에 대한 일반적인 해결책을 제공하는 재사용 가능한 설계입니다. 이러한 패턴들은 과거의 소프트웨어 개발 경험에서 유래되며, 효율적인 코드 재사용, 코드 가독성 및 유지 보수성 향상을 목표로 합니다.

## MVC (Model-View-Controller) 패턴

MVC는 웹 애플리케이션과 GUI 애플리케이션에서 UI와 비즈니스 로직을 분리하기 위한 디자인 패턴입니다.

### 구성 요소:
- **Model**: 데이터와 비즈니스 로직을 캡슐화합니다.
- **View**: 사용자 인터페이스 및 표현 로직을 담당합니다.
- **Controller**: 사용자의 요청을 처리하고, Model과 View 간의 상호작용을 조정합니다.

### Model 1

- 클라이언트의 요청이 JSP 페이지로 직접 이동합니다.
- JSP 페이지 안에서 로직 처리 및 데이터 표현이 이루어집니다.
- 주로 작은 웹 애플리케이션에서 사용됩니다.

### Model 2

- 클라이언트의 요청이 초기에 서블릿에 도달합니다.
- 서블릿(Controller)이 로직을 처리한 후 적절한 JSP(View)로 전달합니다.
- Model, View, Controller가 명확하게 분리되어 있습니다.

## Spring Framework와 MVC

Spring Framework는 자바 플랫폼을 위한 포괄적인 프레임워크입니다. Spring MVC는 이 프레임워크의 일부로, 웹 애플리케이션을 위한 MVC 아키텍처를 제공합니다.

- **Controller**: Spring에서 `@Controller` 어노테이션이 붙은 클래스. 요청 처리 로직을 담당합니다.
- **Model**: `ModelAndView` 객체를 사용하여 데이터를 전달합니다.
- **View**: 주로 JSP, Thymeleaf 등을 사용하여 표현되며, Controller로부터 전달받은 Model 데이터를 사용자에게 표시합니다.


물론 이외에도 많은 디자인 패턴들이 있습니다. 그러나 최근에는 클라우드 컴퓨팅, 마이크로서비스 아키텍처 등의 도입으로 새로운 디자인 패턴들도 등장하고 있습니다.

다양한 문제 상황에서 가장 적절한 디자인 패턴을 선택하는 것은 소프트웨어 아키텍처 및 설계의 핵심적인 부분입니다.


MVC (Model-View-Controller) 패턴은 웹 애플리케이션의 아키텍처를 구조화하는 방법 중 하나입니다. JSP와 서블릿을 사용할 때 주로 두 가지 모델이 사용됩니다: Model 1 아키텍처와 Model 2 아키텍처.

### Model 1 아키텍처

- **직접적인 접근**: 클라이언트는 JSP 페이지에 직접 접근합니다.
- **로직과 표현 혼합**: JSP 페이지 내에서 비즈니스 로직과 표현 로직이 혼합됩니다.
- **컨트롤러 필요 없음**: JSP 페이지 자체가 뷰와 컨트롤러의 역할을 겸합니다.

#### Model 1 예제

```jsp
<!-- mypage.jsp -->
<%
    String name = request.getParameter("name");
    if (name == null || name.isEmpty()) {
        name = "Guest";
    }
%>
<html>
<head>
  <title>Hello</title>
</head>
<body>
  Hello, <%= name %>!
</body>
</html>
```

### Model 2 아키텍처

- **분리된 역할**: Model, View, Controller가 명확하게 분리되어 있습니다.
- **서블릿 컨트롤러**: 서블릿이 컨트롤러의 역할을 하며, 요청을 처리한 후 적절한 뷰(JSP 페이지)로 포워딩합니다.
- **재사용성과 확장성**: 로직과 표현이 분리되어 있기 때문에 재사용성과 확장성이 높습니다.

#### Model 2 예제

```java
// MyServlet.java
@WebServlet("/hello")
public class MyServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String name = request.getParameter("name");
        if (name == null || name.isEmpty()) {
            name = "Guest";
        }
        request.setAttribute("name", name);
        request.getRequestDispatcher("/mypage.jsp").forward(request, response);
    }
}
```

```jsp
<!-- mypage.jsp -->
<html>
<head>
  <title>Hello</title>
</head>
<body>
  Hello, ${name}!
</body>
</html>
```

### 주요 차이점

1. **로직의 분리**: Model 1은 JSP 페이지에서 모든 것을 처리합니다. Model 2는 서블릿과 JSP를 통해 로직과 뷰를 명확하게 분리합니다.
2. **유지 보수성**: Model 2는 유지 보수성이 높고, 코드의 재사용성과 확장성도 높습니다.
3. **복잡성**: Model 1은 작은 프로젝트에 적합하며 빠르게 개발할 수 있습니다. Model 2는 초기 설정이 복잡할 수 있으나, 큰 규모의 애플리케이션에 더 적합합니다.

대체로 현대 웹 애플리케이션 개발에서는 Model 2 아키텍처가 더 선호됩니다.



# MVP (Model-View-Presenter) 패턴

MVP는 GUI 애플리케이션에서 사용되는 아키텍처 패턴 중 하나입니다. MVC 패턴과 비슷하지만, Controller 대신 Presenter를 가지며, View와 Model 사이에 더 강력한 분리를 강조합니다.

## 구성 요소:

- **Model**: 데이터와 비즈니스 로직을 캡슐화합니다.
- **View**: 사용자 인터페이스 및 사용자 입력을 처리합니다.
- **Presenter**: 사용자의 입력에 응답하고, Model과 View 사이의 인터페이스 역할을 합니다.

## 특징:

- View는 인터페이스를 통해 Presenter에 의존합니다.
- Presenter는 View와 Model 사이의 로직을 처리합니다.
- 비즈니스 로직은 Model에 있으며, View는 순수하게 표현만을 담당합니다.

# MVVM (Model-View-ViewModel) 패턴

MVVM 패턴은 주로 데이터 바인딩을 지원하는 프레임워크나 라이브러리에서 사용됩니다. 예를 들면, WPF, Angular, React + Redux 등에서 볼 수 있습니다.

## 구성 요소:

- **Model**: 데이터와 비즈니스 로직을 캡슐화합니다.
- **View**: 사용자 인터페이스를 표현합니다. 사용자의 입력을 처리하고, 데이터를 표시합니다.
- **ViewModel**: View를 위한 데이터와 명령을 캡슐화합니다. View와 Model 사이의 변환기 역할을 합니다.

## 특징:

- **데이터 바인딩**: View는 ViewModel의 데이터와 바인딩되어 자동으로 업데이트됩니다.
- ViewModel은 View에 대한 로직을 처리하지만, View 자체를 알지 못합니다.
- 이 패턴은 유닛 테스트의 용이성을 강조합니다.

# 마이크로서비스 아키텍처

마이크로서비스 아키텍처는 소프트웨어 애플리케이션을 작고 독립적인 서비스들로 분리하여 개발하고 운영하는 설계 방식입니다.

## 특징:

- **독립성**: 각 서비스는 독립적으로 배포하고 확장할 수 있습니다.
- **유연성**: 다양한 기술 스택과 패턴을 사용하여 각 서비스를 구현할 수 있습니다.
- **결합도**: 각 서비스는 잘 정의된 API를 통해 통신합니다.
- **탄력성**: 하나의 서비스에 문제가 발생해도 다른 서비스에 영향을 미치지 않습니다.
- **확장성**: 트래픽이 많은 서비스만 독립적으로 확장할 수 있습니다.

## 고려사항:

- **데이터 관리**: 서비스 간 데이터 일관성을 유지하는 것은 복잡할 수 있습니다.
- **서비스 간 통신**: 서비스 간에는 네트워크 호출을 통한 통신이 필요하므로, 효율적인 통신과 에러 처리가 중요합니다.
- **서비스 발견**: 다수의 서비스를 관리하고 통신할 때 서비스 발견 메커니즘이 필요합니다.

마이크로서비스 아키텍처는 복잡성을 관리하는 도구와 함께 올바르게 구현될 경우, 큰 규모의 시스템에서 확장성과 유연성을 제공할 수 있습니다.

# MSA (Microservices Architecture)

MSA, 즉 마이크로서비스 아키텍처는 현대의 복잡한 소프트웨어 시스템의 요구사항에 응답하기 위해 나온 설계 방식입니다.

## 나오게 된 배경

1. **확장성**: 대규모 시스템은 수백, 수천만 사용자의 요청을 동시에 처리해야 할 때가 많습니다. 이런 확장성을 유연하게 제공하기 위해 필요했습니다.
2. **빠른 출시**: 비즈니스 요구사항이 빠르게 변하며, 신속한 개발과 배포 사이클이 요구되었습니다.
3. **기술 유연성**: 동일한 기술 스택에 구애받지 않고 다양한 기술을 적용할 수 있는 유연성이 필요했습니다.
4. **복잡성 관리**: 대규모 시스템은 복잡해질 수밖에 없습니다. 이 복잡성을 작은 서비스 단위로 나누어 관리하고자 하는 의도가 있었습니다.

## 이전 아키텍처와의 차이: 모놀리식 아키텍처 (Monolithic Architecture)

1. **전체 구조**: 모놀리식은 하나의 큰 애플리케이션으로 구성되어 있으나, 마이크로서비스는 여러 작은 서비스로 나뉘어져 있습니다.
2. **배포**: 모놀리식은 전체 애플리케이션을 다시 배포해야 할 때가 많습니다. 반면, 마이크로서비스는 개별 서비스를 독립적으로 배포할 수 있습니다.
3. **확장성**: 모놀리식은 전체 애플리케이션을 확장해야 하는 반면, 마이크로서비스는 필요한 서비스만 확장할 수 있습니다.
4. **장애 영향도**: 모놀리식에서는 한 부분에 문제가 생기면 전체 시스템에 영향을 줄 수 있습니다. 마이크로서비스에서는 해당 서비스만 영향을 받게 됩니다.

## 대표적인 서비스

1. **Netflix**: 대표적인 온라인 스트리밍 서비스로, 초기 모놀리식 아키텍처에서 마이크로서비스 아키텍처로 전환하여 대규모 사용자를 처리합니다.
2. **Amazon**: 원래의 대규모 모놀리식 아키텍처에서 마이크로서비스로 전환, 서비스의 확장성과 안정성을 높였습니다.
3. **Spotify**: 음악 스트리밍 서비스는 팀 구조와 아키텍처 모두를 마이크로서비스 방식으로 조직화하여 빠른 기능 배포와 확장성을 달성했습니다.

마이크로서비스 아키텍처는 현대의 복잡하고 확장성 있는 시스템 구축에 필수적인 방식이 되어가고 있으며, 많은 대기업부터 스타트업까지 다양한 규모의 회사에서 적용하고 있습니다.
